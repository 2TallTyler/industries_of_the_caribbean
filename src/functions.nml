
/* Begin Functions */

/**
 * Check if an industry is within a range of elevation.
 * @param min_z elevation (inclusive)
 * @param max_z elevation (inclusive)
 * @return 1 if the industry is at or between the specified min and max elevations, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IndustryElevationCheck, min_z, max_z, nearby_tile_height(0,0) >= min_z && nearby_tile_height(0,0) <= max_z) {return;}

/**
 * Check if an industry is unique in a town
 * @param id Industry ID to check
 * @return 1 if there are no industries of this type in a town, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IsUniqueInTown, id, industry_town_count(id) == 0) {return;}

/**
 * Check if a town has sufficient population
 * @param pop The population required
 * @return 1 if the town population is greater than the input parameter, else 0
 */
switch (FEAT_INDUSTRIES, PARENT, TownHasPopulation, pop, population >= pop) {return;}

/**
 * Check if a water-based industry is near land, or a land-based industry is near water
 * @param required distance from land/water
 * @return 1 if the industry is greater than the given distance from land/water, else 0
 */
switch (FEAT_INDUSTRIES, SELF, DistanceFromWaterOrLand, required, water_distance >= required) {return;}

/**
 * Calculate the x coordinate of an industry's northernmost tile.
 * @returns the x coordinate
 */ 
switch (FEAT_INDUSTRIES, SELF, GetTileX, var[0x80, 0, 0xFFFFFFFF] % map_x_edge) {return;}

/**
 * Calculate the y coordinate of an industry's northernmost tile.
 * @returns the y coordinate
 */
switch (FEAT_INDUSTRIES, SELF, GetTileY, var[0x80, 0, 0xFFFFFFFF] / map_x_edge) {return;}
 
/**
 * Checks if an industry is suitably close to the edge of the map
 * @returns 1 if it is close enouugh, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IsNearMapEdge, 
	(GetTileX() < 4) ||
	((map_x_edge - GetTileX()) < 8) ||
	(GetTileY() < 4) ||
	((map_y_edge - GetTileY()) < 8)
) {return;}

/**
 * Checks if an industry is being funded 
 * @returns 1 if so, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IsFundedConstruction, extra_callback_info2 == IND_CREATION_FUND) {return;}

/* Empty production block */
produce (produce_none, [], [])

/* Consume idle workers (no cargo available to process) */ 
produce (produce_idle_workers, [PASS: (incoming_cargo_waiting("PASS") > 200) ? (incoming_cargo_waiting("PASS") / 8) : 3;], [], 0)

switch (FEAT_INDUSTRIES, SELF, switch_produce_idle, incoming_cargo_waiting("PASS") > 0) {
	1: produce_idle_workers;
	produce_none;
}

/**
 * Checks if an industrytile is on a non-desert tile
 * @returns 1 if the tile is not a desert tile, else 0
 */
 switch (FEAT_INDUSTRIES, SELF, IsNotDesert, nearby_tile_terrain_type(0,0) != TILETYPE_DESERT) {1: return 1; return 0;}

 /**
  * Calculate the cargo profit if enabled in NewGRF parameters, or let the callback fail to use the default calculation.
  * This function scales the payment by the map size, so larger maps give greater payments to avoid running costs eating your profits.
  * Base game code scales this returned value by the cargo value and amount transported.
  * @return a custom cargo profit if param_static_payments is enabled, else return CB_FAILED.
  */
switch (FEAT_CARGOS, SELF, CargoProfit, param_static_payments) {1: return 128 + (map_max_edge / 8); return CB_FAILED;}